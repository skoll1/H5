<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <h1>问题</h1>
    <p>
        当网站或引用首次被加载的时候，首先需要准备大量的工作区构造引用的初始状态，然后才是使用这些信息去渲染界面。例如有的应用需要进行身份验证，之后才能进行一些api请求，最后才是将返回的数据呈现到页面中。
        所以说，如果把应用的状态信息存储到indexDb中，可以提升频繁访问页面的加载时间。通过indexDB还能够采用失效更新策略，在后台与任何api进行同步，只有当数据更新的时候才去更新ui。
    </p>
    <h2>主力考虑的是indexDB对于保存状态的方法，而不是考虑如何存储其他数据</h2>
    <ul>
        <li>
            写入存储失败的原因:开发者不能控制的情况
            <ul>
                <li>
                    一些浏览器目前不允许在隐私浏览模式下写入indexDB。
                </li>
                <li>
                    当用户的磁盘快要满了，浏览器会限制存储任何东西。
                </li>
                <li>
                    因此在操作indexDB的代码中执行错误处理操作变得至观重要
                </li>
                <li>
                    存储的数据可能被用户修改或者修改，不像是服务端那样开发者可以限制未经授权的请求，客户端数据库可以被浏览器扩展插件和开发者工具所访问，并且用户可以清除他们。虽然用户修改本地存储的数据不可能，但是清除他们确实很常见的。这个要想到
                </li>
                <li>
                    存储的数据会过期
                </li>
                <li>
                    保持你的程序性能
                    <ul>
                        <li>
                            indexDB不应该读写大于待访问数据的大小。
                        </li>
                        <li>
                            借鉴redux的实例把整个状态树分解为单个记录进行存储，并且只更新实际更改的记录，而不是将整个记录都存储到单个记录中，因为每一次读取都是先要创建该对象的结构化克隆，这个克隆过程会在主线程中进行，因此对象越大，阻塞时间越长。
                        </li>
                    </ul>
                </li>
                <li>
                    开发人员可以利用像indexDB这样的客户端存储机制，不仅能够在会话中持久化妆台，还可以减少在重复访问时加载初始妆台是所需要的时间，从而改善用户的应用体验。
                </li>
            </ul>
        </li>
    </ul>
</body>
</html>